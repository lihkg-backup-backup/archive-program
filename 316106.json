{"tid":316106,"cid":26,"subCid":0,"title":"recursive descent parser係咪一定簡單","createTime":"2017-07-10T13:16:41.000Z","updateTime":"2017-07-11T13:14:25.000Z","uid":122576,"like":0,"dislike":0,"uniUserReply":0,"replies":[{"pid":"31cae5e807808e9bbc0b9315dcd1adefc61b3580","tid":316106,"uid":122576,"like":0,"dislike":0,"score":0,"citedBy":0,"replyTime":"2017-07-10T13:16:41.000Z","msg":"我parse operators嘅時候個expression chain咁長嘅<img src=\"/assets/faces/normal/@.gif\" class=\"hkgmoji\" /> <br />\n<br />\n搞到我唔想寫落去直接table算<img src=\"/assets/faces/normal/sosad.gif\" class=\"hkgmoji\" /> <br />\n<br />\nbtw 除咗operator precedence同shunting yard仲有咩method係可以parse operator?"},{"pid":"05e3e19ddb81b14427c400357cecab13d565637c","tid":316106,"uid":23699,"like":0,"dislike":0,"score":0,"citedBy":0,"replyTime":"2017-07-10T13:26:27.000Z","msg":"長<img src=\"/assets/faces/normal/wonder.gif\" class=\"hkgmoji\" />"},{"pid":"c5e85a947a72ec294b33e1785af537f0a630d2ee","tid":316106,"uid":122576,"like":0,"dislike":0,"score":0,"citedBy":0,"replyTime":"2017-07-10T13:31:48.000Z","msg":"<blockquote>長<img src=\"/assets/faces/normal/wonder.gif\" class=\"hkgmoji\" /></blockquote><br />\n睇bnf<br />\n<blockquote><br />\n&lt;constant-expression&gt; ::= &lt;conditional-expression&gt;<br />\n<br />\n&lt;conditional-expression&gt; ::= &lt;logical-or-expression&gt;<br />\n                           | &lt;logical-or-expression&gt; ? &lt;expression&gt; : &lt;conditional-expression&gt;<br />\n<br />\n&lt;logical-or-expression&gt; ::= &lt;logical-and-expression&gt;<br />\n                          | &lt;logical-or-expression || &lt;logical-and-expression&gt;<br />\n<br />\n&lt;logical-and-expression&gt; ::= &lt;inclusive-or-expression&gt;<br />\n                           | &lt;logical-and-expression &amp;&amp; &lt;inclusive-or-expression&gt;<br />\n<br />\n&lt;inclusive-or-expression&gt; ::= &lt;exclusive-or-expression&gt;<br />\n                            | &lt;inclusive-or-expression&gt; | &lt;exclusive-or-expression&gt;<br />\n<br />\n&lt;exclusive-or-expression&gt; ::= &lt;and-expression&gt;<br />\n                            | &lt;exclusive-or-expression&gt; ^ &lt;and-expression&gt;<br />\n<br />\n&lt;and-expression&gt; ::= &lt;equality-expression&gt;<br />\n                   | &lt;and-expression&gt; &amp; &lt;equality-expression&gt;<br />\n<br />\n&lt;equality-expression&gt; ::= &lt;relational-expression&gt;<br />\n                        | &lt;equality-expression&gt; == &lt;relational-expression&gt;<br />\n                        | &lt;equality-expression&gt; != &lt;relational-expression&gt;<br />\n<br />\n&lt;relational-expression&gt; ::= &lt;shift-expression&gt;<br />\n                          | &lt;relational-expression&gt; &lt; &lt;shift-expression&gt;<br />\n                          | &lt;relational-expression&gt; &gt; &lt;shift-expression&gt;<br />\n                          | &lt;relational-expression&gt; &lt;= &lt;shift-expression&gt;<br />\n                          | &lt;relational-expression&gt; &gt;= &lt;shift-expression&gt;<br />\n<br />\n&lt;shift-expression&gt; ::= &lt;additive-expression&gt;<br />\n                     | &lt;shift-expression&gt; &lt;&lt; &lt;additive-expression&gt;<br />\n                     | &lt;shift-expression&gt; &gt;&gt; &lt;additive-expression&gt;<br />\n<br />\n&lt;additive-expression&gt; ::= &lt;multiplicative-expression&gt;<br />\n                        | &lt;additive-expression&gt; + &lt;multiplicative-expression&gt;<br />\n                        | &lt;additive-expression&gt; - &lt;multiplicative-expression&gt;<br />\n<br />\n&lt;multiplicative-expression&gt; ::= &lt;cast-expression&gt;<br />\n                              | &lt;multiplicative-expression&gt; * &lt;cast-expression&gt;<br />\n                              | &lt;multiplicative-expression&gt; / &lt;cast-expression&gt;<br />\n                              | &lt;multiplicative-expression&gt; % &lt;cast-expression&gt;<br />\n<br />\n&lt;cast-expression&gt; ::= &lt;unary-expression&gt;<br />\n                    | ( &lt;type-name&gt; ) &lt;cast-expression&gt;<br />\n<br />\n&lt;unary-expression&gt; ::= &lt;postfix-expression&gt;<br />\n                     | ++ &lt;unary-expression&gt;<br />\n                     | -- &lt;unary-expression&gt;<br />\n                     | &lt;unary-operator&gt; &lt;cast-expression&gt;<br />\n                     | sizeof &lt;unary-expression&gt;<br />\n                     | sizeof &lt;type-name&gt;<br />\n<br />\n&lt;postfix-expression&gt; ::= &lt;primary-expression&gt;<br />\n                       | &lt;postfix-expression&gt; [ &lt;expression&gt; ]<br />\n                       | &lt;postfix-expression&gt; ( {&lt;assignment-expression&gt;}* )<br />\n                       | &lt;postfix-expression&gt; . &lt;identifier&gt;<br />\n                       | &lt;postfix-expression&gt; -&gt; &lt;identifier&gt;<br />\n                       | &lt;postfix-expression&gt; ++<br />\n                       | &lt;postfix-expression&gt; --<br />\n<br />\n&lt;primary-expression&gt; ::= &lt;identifier&gt;<br />\n                       | &lt;constant&gt;<br />\n                       | &lt;string&gt;<br />\n                       | ( &lt;expression&gt; )<br />\n<br />\n&lt;constant&gt; ::= &lt;integer-constant&gt;<br />\n             | &lt;character-constant&gt;<br />\n             | &lt;floating-constant&gt;<br />\n             | &lt;enumeration-constant&gt;<br />\n<br />\n&lt;expression&gt; ::= &lt;assignment-expression&gt;<br />\n               | &lt;expression&gt; , &lt;assignment-expression&gt;<br />\n<br />\n&lt;assignment-expression&gt; ::= &lt;conditional-expression&gt;<br />\n                          | &lt;unary-expression&gt; &lt;assignment-operator&gt; &lt;assignment-expression&gt;<br />\n<br />\n&lt;assignment-operator&gt; ::= =<br />\n                        | *=<br />\n                        | /=<br />\n                        | %=<br />\n                        | +=<br />\n                        | -=<br />\n                        | &lt;&lt;=<br />\n                        | &gt;&gt;=<br />\n                        | &amp;=<br />\n                        | ^=<br />\n                        | |=<br />\n<br />\n&lt;unary-operator&gt; ::= &amp;<br />\n                   | *<br />\n                   | +<br />\n                   | -<br />\n                   | ~<br />\n                   | !<br />\n</blockquote>"},{"pid":"fc448117cd781328fbe221fe03b94d6ddc2a5f8c","tid":316106,"uid":122576,"like":0,"dislike":0,"score":0,"citedBy":0,"replyTime":"2017-07-10T13:32:12.000Z","msg":"<blockquote><br />\n睇bnf<br />\n</blockquote><br />\n真係幾長下"},{"pid":"f6433be2d8c45c15bfc7c90e26215c11d4413352","tid":316106,"uid":122576,"like":0,"dislike":0,"score":0,"citedBy":0,"replyTime":"2017-07-10T13:34:12.000Z","msg":"<blockquote><blockquote><br />\n睇bnf<br />\n</blockquote><br />\n真係幾長下</blockquote><br />\n我自己用c++ 純手寫都寫到手軟 stack debug又麻煩<br />\n我改咗用RDP+Shunting yard<br />\n<br />\n<blockquote><br />\nprivate: expr_node *expr() {<br />\n\t\tstd::vector&lt;node*&gt; outQueue;<br />\n\t\tstd::vector&lt;token&gt; opStack;<br />\n<br />\n\t\twhile (!consumed()) {<br />\n\t\t\tif (auto exp = primary()) {<br />\n\t\t\t\toutQueue.push_back(exp);<br />\n\t\t\t\tcontinue;<br />\n\t\t\t}<br />\n<br />\n\t\t\tif (consumed()) {<br />\n\t\t\t\tbreak;<br />\n\t\t\t}<br />\n<br />\n\t\t\tif (precedences.find(current().type) != precedences.end()) { <br />\n\t\t\t\ttoken captured = current();<br />\n\t\t\t\tauto thisPrec = precedences[captured.type];<br />\n\t\t\t\tnext();<br />\n\t\t\t\t// state modified<br />\n<br />\n\t\t\t\tif (opStack.size() &gt; 0) {<br />\n\t\t\t\t\tfor (<br />\n\t\t\t\t\t\tauto topPrec = precedences[opStack.back().type];<br />\n\t\t\t\t\t\t(topPrec.precedence &gt;= thisPrec.precedence) ||<br />\n\t\t\t\t\t\t(topPrec.rightAsso &amp;&amp; (topPrec.precedence &gt; thisPrec.precedence));<br />\n\t\t\t\t\t\ttopPrec = precedences[opStack.back().type]<br />\n\t\t\t\t\t) {<br />\n\t\t\t\t\t\tauto opNode = new operator_node;<br />\n\t\t\t\t\t\topNode-&gt;oper_token = opStack.back();<br />\n\t\t\t\t\t\topStack.pop_back();<br />\n\t\t\t\t\t\t// state of opStack changed<br />\n\t\t\t\t\t\toutQueue.push_back(opNode);<br />\n\t\t\t\t\t\t<br />\n\t\t\t\t\t\tif (opStack.size() &lt; 1) { <br />\n\t\t\t\t\t\t\tbreak;<br />\n\t\t\t\t\t\t}<br />\n\t\t\t\t\t}<br />\n\t\t\t\t}<br />\n\t\t\t\topStack.push_back(captured);<br />\n\t\t\t} else { // hit something unusual to expr such as ';', ')'<br />\n\t\t\t\tbreak;<br />\n\t\t\t}<br />\n\t\t}<br />\n<br />\n\t\twhile (opStack.size() &gt; 0) {<br />\n\t\t\tauto token = new operator_node;<br />\n\t\t\ttoken-&gt;oper_token = opStack.back();<br />\n\t\t\topStack.pop_back();<br />\n\t\t\toutQueue.push_back(token);<br />\n\t\t}<br />\n<br />\n\t\tint len = outQueue.size();<br />\n<br />\n\t\tif (len &lt; 1) {<br />\n\t\t\treturn nullptr;<br />\n\t\t}<br />\n<br />\n\t\tstd::vector&lt;expr_node*&gt; exprOutQueue;<br />\n\t\tfor (int i = 0; i &lt; len; i++) {<br />\n\t\t\tauto out = outQueue[i];<br />\n<br />\n\t\t\tif (out-&gt;type() == &quot;operator_node&quot;) {<br />\n\t\t\t\tauto token = (operator_node*)out;<br />\n\t\t\t\tauto opType = token-&gt;oper_token.type;<br />\n\t\t\t\tif (opType == &quot;!&quot; || opType == &quot;~&quot;) {<br />\n\t\t\t\t\t// unary operator<br />\n\t\t\t\t\t// op rhs<br />\n\t\t\t\t\tauto unary = new unary_expr_node;<br />\n<br />\n\t\t\t\t\tauto rhs = exprOutQueue.back();<br />\n\t\t\t\t\texprOutQueue.pop_back();<br />\n<br />\n\t\t\t\t\tunary-&gt;oper = token;<br />\n\t\t\t\t\tunary-&gt;expr = rhs;<br />\n<br />\n\t\t\t\t\texprOutQueue.push_back(unary);<br />\n\t\t\t\t} else if (opType == &quot;?&quot;) {<br />\n\t\t\t\t\t// assumed to be ternary operator<br />\n\t\t\t\t\t// expr ? expr : expr<br />\n\t\t\t\t} else {<br />\n\t\t\t\t\t// assumed to be binary operator<br />\n\t\t\t\t\t// lhs op rhs<br />\n\t\t\t\t\tauto binary = new binary_expr_node;<br />\n<br />\n\t\t\t\t\tauto rhs = exprOutQueue.back();<br />\n\t\t\t\t\texprOutQueue.pop_back();<br />\n<br />\n\t\t\t\t\tauto lhs = exprOutQueue.back();<br />\n\t\t\t\t\texprOutQueue.pop_back();<br />\n<br />\n\t\t\t\t\tbinary-&gt;lhs = lhs;<br />\n\t\t\t\t\tbinary-&gt;rhs = rhs;<br />\n\t\t\t\t\tbinary-&gt;token = token;<br />\n<br />\n\t\t\t\t\texprOutQueue.push_back(binary);<br />\n\t\t\t\t}<br />\n\t\t\t} else {<br />\n\t\t\t\texprOutQueue.push_back((expr_node*)out);<br />\n\t\t\t}<br />\n\t\t}<br />\n<br />\n\t\treturn exprOutQueue[0]; // if a valid tree forms, there will be one and only element<br />\n\t}<br />\n</blockquote>"},{"pid":"b4b5ff2e4261b51c8442057997548954ff519e66","tid":316106,"uid":122576,"like":0,"dislike":0,"score":0,"citedBy":0,"replyTime":"2017-07-10T13:34:59.000Z","msg":"sor 睇呢個<br />\n<br />\n<a href=\"https://pastebin.com/3aBy4b66\" data-sr-url=\"https://r.lihkg.com/link?u=https%3A%2F%2Fpastebin.com%2F3aBy4b66&d=xrBEIkkbOI%2BdwT7Vu8BMYaEKYqckrLkk14koP0tj2xA%3D&h=c6eb9d0c\" data-auto-link target=\"_blank\">https://pastebin.com/3aBy4b66</a>"},{"pid":"dbad674cbf99374d54bf0a0fc006c65290e30856","tid":316106,"uid":28563,"like":0,"dislike":0,"score":0,"citedBy":0,"replyTime":"2017-07-10T14:12:19.000Z","msg":"留明睇lihkgcc<img src=\"/assets/faces/normal/hehe.gif\" class=\"hkgmoji\" />"},{"pid":"85fac40fd4c7d41e46be2f1b58302b537beed281","tid":316106,"uid":122576,"like":0,"dislike":0,"score":0,"citedBy":0,"replyTime":"2017-07-10T14:23:09.000Z","msg":"<blockquote>留明睇lihkgcc<img src=\"/assets/faces/normal/hehe.gif\" class=\"hkgmoji\" /></blockquote><br />\n算鳩數吧啦<img src=\"/assets/faces/normal/no.gif\" class=\"hkgmoji\" /> <br />\n<br />\n我廢 連automata都未識 未學行先學走<img src=\"/assets/faces/normal/clown.gif\" class=\"hkgmoji\" /> <br />\n<br />\n你寫一個就有可能"},{"pid":"689a328445f87e13afceca8422ff58037a8ada1d","tid":316106,"uid":28563,"like":0,"dislike":0,"score":0,"citedBy":0,"replyTime":"2017-07-10T16:25:00.000Z","msg":"<blockquote><blockquote>留明睇lihkgcc<img src=\"/assets/faces/normal/hehe.gif\" class=\"hkgmoji\" /></blockquote><br />\n算鳩數吧啦<img src=\"/assets/faces/normal/no.gif\" class=\"hkgmoji\" /> <br />\n<br />\n我廢 連automata都未識 未學行先學走<img src=\"/assets/faces/normal/clown.gif\" class=\"hkgmoji\" /> <br />\n<br />\n你寫一個就有可能</blockquote><br />\n我識nier automata<img src=\"/assets/faces/normal/agree.gif\" class=\"hkgmoji\" />"},{"pid":"a9599dff4c5552f53c10d62c14178ddf388cfe0e","tid":316106,"uid":105553,"like":0,"dislike":0,"score":0,"citedBy":0,"replyTime":"2017-07-10T16:54:01.000Z","msg":"個concept好簡單但個parser可以好複雜，睇grammar。"},{"pid":"34dce378e0638c5741697d8f5701fa907034d47a","tid":316106,"uid":105553,"like":0,"dislike":0,"score":0,"citedBy":0,"replyTime":"2017-07-10T17:03:28.000Z","msg":"呢個係C嘅grammar？當年AT&amp;T Bell Lab嘅C compiler好似都唔係100%recursive decent。expression部份係用precedence 。<br />\n<br />\n如果係C++就祝你好運，因為要做template。<img src=\"/assets/faces/normal/hehe.gif\" class=\"hkgmoji\" />"},{"pid":"3adfe41c43f44acfd9f0d53686e4c604051de2cf","tid":316106,"uid":122576,"like":0,"dislike":0,"score":0,"citedBy":0,"replyTime":"2017-07-11T01:13:36.000Z","msg":"<blockquote>呢個係C嘅grammar？當年AT&amp;T Bell Lab嘅C compiler好似都唔係100%recursive decent。expression部份係用precedence 。<br />\n<br />\n如果係C++就祝你好運，因為要做template。<img src=\"/assets/faces/normal/hehe.gif\" class=\"hkgmoji\" /></blockquote><br />\n係<br />\n<br />\ntemplate真係咁仆街<img src=\"/assets/faces/normal/@.gif\" class=\"hkgmoji\" /> <br />\n都係generic好"},{"pid":"4095a16197eef4fb33d1bf7ad30052f07ca8537f","tid":316106,"uid":23699,"like":0,"dislike":0,"score":0,"citedBy":0,"replyTime":"2017-07-11T03:36:03.000Z","msg":"<blockquote><blockquote>呢個係C嘅grammar？當年AT&amp;T Bell Lab嘅C compiler好似都唔係100%recursive decent。expression部份係用precedence 。<br />\n<br />\n如果係C++就祝你好運，因為要做template。<img src=\"/assets/faces/normal/hehe.gif\" class=\"hkgmoji\" /></blockquote><br />\n係<br />\n<br />\ntemplate真係咁仆街<img src=\"/assets/faces/normal/@.gif\" class=\"hkgmoji\" /> <br />\n都係generic好</blockquote><br />\n有啲grammer簡單 用recursive descent 好易寫<br />\n例如json <img src=\"/assets/faces/normal/sosad.gif\" class=\"hkgmoji\" />"},{"pid":"7d6bc2676b79069720a3a7f7d15fed676590729c","tid":316106,"uid":122576,"like":0,"dislike":0,"score":0,"citedBy":0,"replyTime":"2017-07-11T06:13:43.000Z","msg":"<blockquote><blockquote><blockquote>呢個係C嘅grammar？當年AT&amp;T Bell Lab嘅C compiler好似都唔係100%recursive decent。expression部份係用precedence 。<br />\n<br />\n如果係C++就祝你好運，因為要做template。<img src=\"/assets/faces/normal/hehe.gif\" class=\"hkgmoji\" /></blockquote><br />\n係<br />\n<br />\ntemplate真係咁仆街<img src=\"/assets/faces/normal/@.gif\" class=\"hkgmoji\" /> <br />\n都係generic好</blockquote><br />\n有啲grammer簡單 用recursive descent 好易寫<br />\n例如json <img src=\"/assets/faces/normal/sosad.gif\" class=\"hkgmoji\" /></blockquote><br />\n寫緊一個類似c# java嘅language<br />\n<br />\n有機會用嚟當fyp"},{"pid":"b6e025f86ec696e4a7a3bdc0d2681ecedc204ed5","tid":316106,"uid":23699,"like":0,"dislike":0,"score":0,"citedBy":0,"replyTime":"2017-07-11T13:14:25.000Z","msg":"<blockquote><blockquote><blockquote><blockquote>呢個係C嘅grammar？當年AT&amp;T Bell Lab嘅C compiler好似都唔係100%recursive decent。expression部份係用precedence 。<br />\n<br />\n如果係C++就祝你好運，因為要做template。<img src=\"/assets/faces/normal/hehe.gif\" class=\"hkgmoji\" /></blockquote><br />\n係<br />\n<br />\ntemplate真係咁仆街<img src=\"/assets/faces/normal/@.gif\" class=\"hkgmoji\" /> <br />\n都係generic好</blockquote><br />\n有啲grammer簡單 用recursive descent 好易寫<br />\n例如json <img src=\"/assets/faces/normal/sosad.gif\" class=\"hkgmoji\" /></blockquote><br />\n寫緊一個類似c# java嘅language<br />\n<br />\n有機會用嚟當fyp</blockquote><br />\n早啲訓等派位啦<img src=\"/assets/faces/normal/sosad.gif\" class=\"hkgmoji\" /> <img src=\"/assets/faces/normal/sosad.gif\" class=\"hkgmoji\" />"}]}