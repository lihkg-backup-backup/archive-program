{"tid":1998878,"cid":18,"subCid":0,"title":"[請教] 其實cpu點知幾時run完一個program","createTime":"2020-05-02T17:42:45.000Z","updateTime":"2020-05-04T14:14:40.000Z","uid":137768,"like":1,"dislike":0,"uniUserReply":6,"replies":[{"pid":"28880f37f118476e6fdc2052526a251dc07e188f","tid":1998878,"uid":137768,"like":0,"dislike":0,"score":0,"citedBy":0,"replyTime":"2020-05-02T17:42:45.000Z","msg":"以我所知 cpu應該會用pipeline咁行 不停fetch, decode, execute instructions 咁program同program之間係點樣分隔? Google過話有一個HALT instruction 可以暫停粒U去等另一個interupt. <br />\n<a href=\"https://en.m.wikipedia.org/wiki/HLT_(x86_instruction\" data-sr-url=\"https://r.lihkg.com/link?u=https%3A%2F%2Fen.m.wikipedia.org%2Fwiki%2FHLT_%28x86_instruction&d=eQX%2BqlmYp67lP1AM6ayufQXckNDuUEQQ0Md4EdtPbyE%3D&h=098e625f\" data-auto-link target=\"_blank\">https://en.m.wikipedia.org/wiki/HLT_(x86_instruction</a>) <br />\n<br />\n但內容無提過呢個instruction會清除data cache/instruction cache, 咁run第2個program時會唔會唔小心用翻上一個program殘留嘅數值<img src=\"/assets/faces/normal/wonder.gif\" class=\"hkgmoji\" /><br />\n<br />\n而且我搵過啲online compiler玩過下 寫左個function 最後都係一個RET instruction做ending<img src=\"/assets/faces/normal/cry.gif\" class=\"hkgmoji\" />咁係咪姐係其實有啲隱藏嘅default instructions 會先CALL main() function行某個program 等佢RET翻黎 然後有個HALT喺最後去stop粒U同有另一個instruction去Invalidate所有cache<img src=\"/assets/faces/normal/wonder.gif\" class=\"hkgmoji\" /><br />\n<br />\n<img src=\"/assets/faces/normal/cry.gif\" class=\"hkgmoji\" />sorry for 1999"},{"pid":"b3dc7a6cb16c1126f5386e6961971d81f756bcab","tid":1998878,"uid":343361,"like":0,"dislike":0,"score":0,"citedBy":0,"replyTime":"2020-05-02T17:46:35.000Z","msg":"<span style=\"font-size: x-large;\">去學下memory management 先</span>"},{"pid":"23d2167b5f1152fa89ca04225e3c9dae738bff10","tid":1998878,"uid":297436,"like":5,"dislike":0,"score":5,"citedBy":0,"replyTime":"2020-05-02T17:46:43.000Z","msg":"你問緊係兩個問題嚟<br />\n<br />\n&ldquo;咁run第2個program時會唔會唔小心用翻上一個program殘留嘅數值&rdquo;<br />\n其實係會 如果你個Variable無Assign過任何Value嘅話<img src=\"/assets/faces/dog/give.gif\" class=\"hkgmoji\" /><br />\n所以先要Initialize所有Variable 確保上手個Value洗走咗"},{"pid":"d7d589d07a79fe0cb46a20d4b9fe17aab300f047","tid":1998878,"uid":35507,"like":0,"dislike":0,"score":0,"citedBy":0,"replyTime":"2020-05-02T17:47:22.000Z","msg":"kill -9"},{"pid":"b2694d7bb0c9b7e6b8f3266bdfd60d5aee17341e","tid":1998878,"uid":137768,"like":0,"dislike":0,"score":0,"citedBy":2,"replyTime":"2020-05-02T18:13:49.000Z","msg":"<blockquote>你問緊係兩個問題嚟<br />\n<br />\n&ldquo;咁run第2個program時會唔會唔小心用翻上一個program殘留嘅數值&rdquo;<br />\n其實係會 如果你個Variable無Assign過任何Value嘅話<img src=\"/assets/faces/dog/give.gif\" class=\"hkgmoji\" /><br />\n所以先要Initialize所有Variable 確保上手個Value洗走咗</blockquote><br />\n或者我其實係想問點樣handle program同program之間嘅cache invalidation 如果唔係就算reset翻個PC佢都有機會係run緊前一個program留低嘅instruction 而唔會initialize啲variables<img src=\"/assets/faces/normal/wonder.gif\" class=\"hkgmoji\" />"},{"pid":"ac2839b8955efc5ccafb8804565f38b12a5dacf5","tid":1998878,"uid":147721,"like":1,"dislike":0,"score":1,"quote":{"pid":"b2694d7bb0c9b7e6b8f3266bdfd60d5aee17341e","tid":1998878,"uid":137768,"like":0,"dislike":0,"score":0,"citedBy":2,"replyTime":"2020-05-02T18:13:49.000Z","msg":"<blockquote>你問緊係兩個問題嚟<br />\n<br />\n&ldquo;咁run第2個program時會唔會唔小心用翻上一個program殘留嘅數值&rdquo;<br />\n其實係會 如果你個Variable無Assign過任何Value嘅話<img src=\"/assets/faces/dog/give.gif\" class=\"hkgmoji\" /><br />\n所以先要Initialize所有Variable 確保上手個Value洗走咗</blockquote><br />\n或者我其實係想問點樣handle program同program之間嘅cache invalidation 如果唔係就算reset翻個PC佢都有機會係run緊前一個program留低嘅instruction 而唔會initialize啲variables<img src=\"/assets/faces/normal/wonder.gif\" class=\"hkgmoji\" />"},"citedBy":0,"replyTime":"2020-05-02T18:55:57.000Z","msg":"學下OS既context switch同scheduler"},{"pid":"d833fa740f8ecb86761fc6b4bac14c50fe8c59e8","tid":1998878,"uid":36995,"like":1,"dislike":0,"score":1,"quote":{"pid":"b2694d7bb0c9b7e6b8f3266bdfd60d5aee17341e","tid":1998878,"uid":137768,"like":0,"dislike":0,"score":0,"citedBy":2,"replyTime":"2020-05-02T18:13:49.000Z","msg":"<blockquote>你問緊係兩個問題嚟<br />\n<br />\n&ldquo;咁run第2個program時會唔會唔小心用翻上一個program殘留嘅數值&rdquo;<br />\n其實係會 如果你個Variable無Assign過任何Value嘅話<img src=\"/assets/faces/dog/give.gif\" class=\"hkgmoji\" /><br />\n所以先要Initialize所有Variable 確保上手個Value洗走咗</blockquote><br />\n或者我其實係想問點樣handle program同program之間嘅cache invalidation 如果唔係就算reset翻個PC佢都有機會係run緊前一個program留低嘅instruction 而唔會initialize啲variables<img src=\"/assets/faces/normal/wonder.gif\" class=\"hkgmoji\" />"},"citedBy":1,"replyTime":"2020-05-02T18:56:51.000Z","msg":"所以舊式少少既program language <br />\n首先要define a variable and set a default value<br />\n<br />\n你寫過Assembly language 就知 memory block 會有上一手殘留數值<br />\n<br />\n新啲既language IDE （python pycham)<br />\n應該會幫你run program 前清左殘留數值"},{"pid":"2c05397be6e9fa5ca392b48535178acf1b2f3810","tid":1998878,"uid":137768,"like":0,"dislike":0,"score":0,"quote":{"pid":"d833fa740f8ecb86761fc6b4bac14c50fe8c59e8","tid":1998878,"uid":36995,"like":1,"dislike":0,"score":1,"quote":{"pid":"b2694d7bb0c9b7e6b8f3266bdfd60d5aee17341e","tid":1998878,"uid":137768,"like":0,"dislike":0,"score":0,"citedBy":2,"replyTime":"2020-05-02T18:13:49.000Z","msg":"<blockquote>你問緊係兩個問題嚟<br />\n<br />\n&ldquo;咁run第2個program時會唔會唔小心用翻上一個program殘留嘅數值&rdquo;<br />\n其實係會 如果你個Variable無Assign過任何Value嘅話<img src=\"/assets/faces/dog/give.gif\" class=\"hkgmoji\" /><br />\n所以先要Initialize所有Variable 確保上手個Value洗走咗</blockquote><br />\n或者我其實係想問點樣handle program同program之間嘅cache invalidation 如果唔係就算reset翻個PC佢都有機會係run緊前一個program留低嘅instruction 而唔會initialize啲variables<img src=\"/assets/faces/normal/wonder.gif\" class=\"hkgmoji\" />"},"citedBy":1,"replyTime":"2020-05-02T18:56:51.000Z","msg":"所以舊式少少既program language <br />\n首先要define a variable and set a default value<br />\n<br />\n你寫過Assembly language 就知 memory block 會有上一手殘留數值<br />\n<br />\n新啲既language IDE （python pycham)<br />\n應該會幫你run program 前清左殘留數值"},"citedBy":2,"replyTime":"2020-05-03T03:26:24.000Z","msg":"或者我問得清楚啲 你要reset翻某個variable以我理解其實都係用緊MOV instruction 將某個default value store翻去個main memory度 但前題係你點保證個cpu識run呢一條新嘅指令 given某啲舊嘅指令仲喺個cache度 <br />\n所以我理解係係咪要先做cache invalidation? 咁但係係邊條指令會explicity invalidate所有cache before program start? 抑或係佢每次fetch之前先會同main memory cross check 呢個就係我唔明嘅地方 定唔同cpu做法唔同<img src=\"/assets/faces/normal/wonder.gif\" class=\"hkgmoji\" />"},{"pid":"080957dc799c49c7a4fc1a929ec385c3060fb5b3","tid":1998878,"uid":297436,"like":1,"dislike":0,"score":1,"quote":{"pid":"2c05397be6e9fa5ca392b48535178acf1b2f3810","tid":1998878,"uid":137768,"like":0,"dislike":0,"score":0,"quote":{"pid":"d833fa740f8ecb86761fc6b4bac14c50fe8c59e8","tid":1998878,"uid":36995,"like":1,"dislike":0,"score":1,"quote":{"pid":"b2694d7bb0c9b7e6b8f3266bdfd60d5aee17341e","tid":1998878,"uid":137768,"like":0,"dislike":0,"score":0,"citedBy":2,"replyTime":"2020-05-02T18:13:49.000Z","msg":"<blockquote>你問緊係兩個問題嚟<br />\n<br />\n&ldquo;咁run第2個program時會唔會唔小心用翻上一個program殘留嘅數值&rdquo;<br />\n其實係會 如果你個Variable無Assign過任何Value嘅話<img src=\"/assets/faces/dog/give.gif\" class=\"hkgmoji\" /><br />\n所以先要Initialize所有Variable 確保上手個Value洗走咗</blockquote><br />\n或者我其實係想問點樣handle program同program之間嘅cache invalidation 如果唔係就算reset翻個PC佢都有機會係run緊前一個program留低嘅instruction 而唔會initialize啲variables<img src=\"/assets/faces/normal/wonder.gif\" class=\"hkgmoji\" />"},"citedBy":1,"replyTime":"2020-05-02T18:56:51.000Z","msg":"所以舊式少少既program language <br />\n首先要define a variable and set a default value<br />\n<br />\n你寫過Assembly language 就知 memory block 會有上一手殘留數值<br />\n<br />\n新啲既language IDE （python pycham)<br />\n應該會幫你run program 前清左殘留數值"},"citedBy":2,"replyTime":"2020-05-03T03:26:24.000Z","msg":"或者我問得清楚啲 你要reset翻某個variable以我理解其實都係用緊MOV instruction 將某個default value store翻去個main memory度 但前題係你點保證個cpu識run呢一條新嘅指令 given某啲舊嘅指令仲喺個cache度 <br />\n所以我理解係係咪要先做cache invalidation? 咁但係係邊條指令會explicity invalidate所有cache before program start? 抑或係佢每次fetch之前先會同main memory cross check 呢個就係我唔明嘅地方 定唔同cpu做法唔同<img src=\"/assets/faces/normal/wonder.gif\" class=\"hkgmoji\" />"},"citedBy":1,"replyTime":"2020-05-03T05:22:40.000Z","msg":"其實係唔同Level嘅問題嚟<br />\n最基本嘅Processor係唔會有「轉Program」嘅問題<br />\n因為只係行死一個Program 你Flash邊個落去就行邊個<br />\n即係好似Arduino入面粒ATmega328咁<br />\n唔知你有無玩過<img src=\"/assets/faces/normal/sosad.gif\" class=\"hkgmoji\" /><br />\n<br />\n咁所以要做到「轉Program」依個功能<br />\n後面一定會有更加Low-level嘅Process去處理問題<br />\n咁就已經唔會喺啲Code入面見到個Process"},{"pid":"579ac4876108705e7fc4f856c07a93a923a3938c","tid":1998878,"uid":36995,"like":1,"dislike":0,"score":1,"quote":{"pid":"2c05397be6e9fa5ca392b48535178acf1b2f3810","tid":1998878,"uid":137768,"like":0,"dislike":0,"score":0,"quote":{"pid":"d833fa740f8ecb86761fc6b4bac14c50fe8c59e8","tid":1998878,"uid":36995,"like":1,"dislike":0,"score":1,"quote":{"pid":"b2694d7bb0c9b7e6b8f3266bdfd60d5aee17341e","tid":1998878,"uid":137768,"like":0,"dislike":0,"score":0,"citedBy":2,"replyTime":"2020-05-02T18:13:49.000Z","msg":"<blockquote>你問緊係兩個問題嚟<br />\n<br />\n&ldquo;咁run第2個program時會唔會唔小心用翻上一個program殘留嘅數值&rdquo;<br />\n其實係會 如果你個Variable無Assign過任何Value嘅話<img src=\"/assets/faces/dog/give.gif\" class=\"hkgmoji\" /><br />\n所以先要Initialize所有Variable 確保上手個Value洗走咗</blockquote><br />\n或者我其實係想問點樣handle program同program之間嘅cache invalidation 如果唔係就算reset翻個PC佢都有機會係run緊前一個program留低嘅instruction 而唔會initialize啲variables<img src=\"/assets/faces/normal/wonder.gif\" class=\"hkgmoji\" />"},"citedBy":1,"replyTime":"2020-05-02T18:56:51.000Z","msg":"所以舊式少少既program language <br />\n首先要define a variable and set a default value<br />\n<br />\n你寫過Assembly language 就知 memory block 會有上一手殘留數值<br />\n<br />\n新啲既language IDE （python pycham)<br />\n應該會幫你run program 前清左殘留數值"},"citedBy":2,"replyTime":"2020-05-03T03:26:24.000Z","msg":"或者我問得清楚啲 你要reset翻某個variable以我理解其實都係用緊MOV instruction 將某個default value store翻去個main memory度 但前題係你點保證個cpu識run呢一條新嘅指令 given某啲舊嘅指令仲喺個cache度 <br />\n所以我理解係係咪要先做cache invalidation? 咁但係係邊條指令會explicity invalidate所有cache before program start? 抑或係佢每次fetch之前先會同main memory cross check 呢個就係我唔明嘅地方 定唔同cpu做法唔同<img src=\"/assets/faces/normal/wonder.gif\" class=\"hkgmoji\" />"},"citedBy":1,"replyTime":"2020-05-03T08:11:51.000Z","msg":"例如MIPS CPU 有32個registers <br />\n$R0-$R31<br />\n<br />\nCache <br />\n$C0-$C128<br />\n<br />\nMemory<br />\n$T0-$T1024<br />\n<br />\n# sum = x + y<br />\n    lw      $t0, R0          # Load x from memory into a CPU register<br />\n    lw      $t1, R1          # Load y from memory into a CPU register<br />\n    add     $t0, $R0, $R1   # Add x and y<br />\n    sw      $t0, sum        # Store the result from the CPU register to memory<br />\n<br />\n好簡單既加法<br />\n你做加數前 你要知道每一個register/cache/memory <br />\n入面有咩數值 即係你講既Value invalidation <br />\n<br />\n如果你唔知道一個memory入面有咩數字<br />\n你要直接load一個數字入去<br />\n確保唔會係殘留數值而計錯數"},{"pid":"a250813e2c221dd74cf5b80ae0c07f6c56a76c65","tid":1998878,"uid":137768,"like":0,"dislike":0,"score":0,"quote":{"pid":"579ac4876108705e7fc4f856c07a93a923a3938c","tid":1998878,"uid":36995,"like":1,"dislike":0,"score":1,"quote":{"pid":"2c05397be6e9fa5ca392b48535178acf1b2f3810","tid":1998878,"uid":137768,"like":0,"dislike":0,"score":0,"quote":{"pid":"d833fa740f8ecb86761fc6b4bac14c50fe8c59e8","tid":1998878,"uid":36995,"like":1,"dislike":0,"score":1,"citedBy":1,"replyTime":"2020-05-02T18:56:51.000Z","msg":"所以舊式少少既program language <br />\n首先要define a variable and set a default value<br />\n<br />\n你寫過Assembly language 就知 memory block 會有上一手殘留數值<br />\n<br />\n新啲既language IDE （python pycham)<br />\n應該會幫你run program 前清左殘留數值"},"citedBy":2,"replyTime":"2020-05-03T03:26:24.000Z","msg":"或者我問得清楚啲 你要reset翻某個variable以我理解其實都係用緊MOV instruction 將某個default value store翻去個main memory度 但前題係你點保證個cpu識run呢一條新嘅指令 given某啲舊嘅指令仲喺個cache度 <br />\n所以我理解係係咪要先做cache invalidation? 咁但係係邊條指令會explicity invalidate所有cache before program start? 抑或係佢每次fetch之前先會同main memory cross check 呢個就係我唔明嘅地方 定唔同cpu做法唔同<img src=\"/assets/faces/normal/wonder.gif\" class=\"hkgmoji\" />"},"citedBy":1,"replyTime":"2020-05-03T08:11:51.000Z","msg":"例如MIPS CPU 有32個registers <br />\n$R0-$R31<br />\n<br />\nCache <br />\n$C0-$C128<br />\n<br />\nMemory<br />\n$T0-$T1024<br />\n<br />\n# sum = x + y<br />\n    lw      $t0, R0          # Load x from memory into a CPU register<br />\n    lw      $t1, R1          # Load y from memory into a CPU register<br />\n    add     $t0, $R0, $R1   # Add x and y<br />\n    sw      $t0, sum        # Store the result from the CPU register to memory<br />\n<br />\n好簡單既加法<br />\n你做加數前 你要知道每一個register/cache/memory <br />\n入面有咩數值 即係你講既Value invalidation <br />\n<br />\n如果你唔知道一個memory入面有咩數字<br />\n你要直接load一個數字入去<br />\n確保唔會係殘留數值而計錯數"},"citedBy":0,"replyTime":"2020-05-04T03:07:02.000Z","msg":"或者我理解有錯 用你嘅例子 個cpu run第一條instruction時會搵$T0係乜野 佢會先從cache搵 如果cache hit 佢會直接從$C0 (假設direct mapping啦)load個數 而唔會去main memory 如果cache miss 佢先會將$T0overwrite$C0同埋正確咁將$C0 load入$R1 呢個先係programmer想做到嘅野 而我嘅問題係 佢run第2program時 係咪有條指令/某啲operation令到佢所有cache都會先做invalidation"},{"pid":"f9e05fa37dbc0ec6ab9748655e303dd8889e422a","tid":1998878,"uid":137768,"like":0,"dislike":0,"score":0,"quote":{"pid":"080957dc799c49c7a4fc1a929ec385c3060fb5b3","tid":1998878,"uid":297436,"like":1,"dislike":0,"score":1,"quote":{"pid":"2c05397be6e9fa5ca392b48535178acf1b2f3810","tid":1998878,"uid":137768,"like":0,"dislike":0,"score":0,"quote":{"pid":"d833fa740f8ecb86761fc6b4bac14c50fe8c59e8","tid":1998878,"uid":36995,"like":1,"dislike":0,"score":1,"citedBy":1,"replyTime":"2020-05-02T18:56:51.000Z","msg":"所以舊式少少既program language <br />\n首先要define a variable and set a default value<br />\n<br />\n你寫過Assembly language 就知 memory block 會有上一手殘留數值<br />\n<br />\n新啲既language IDE （python pycham)<br />\n應該會幫你run program 前清左殘留數值"},"citedBy":2,"replyTime":"2020-05-03T03:26:24.000Z","msg":"或者我問得清楚啲 你要reset翻某個variable以我理解其實都係用緊MOV instruction 將某個default value store翻去個main memory度 但前題係你點保證個cpu識run呢一條新嘅指令 given某啲舊嘅指令仲喺個cache度 <br />\n所以我理解係係咪要先做cache invalidation? 咁但係係邊條指令會explicity invalidate所有cache before program start? 抑或係佢每次fetch之前先會同main memory cross check 呢個就係我唔明嘅地方 定唔同cpu做法唔同<img src=\"/assets/faces/normal/wonder.gif\" class=\"hkgmoji\" />"},"citedBy":1,"replyTime":"2020-05-03T05:22:40.000Z","msg":"其實係唔同Level嘅問題嚟<br />\n最基本嘅Processor係唔會有「轉Program」嘅問題<br />\n因為只係行死一個Program 你Flash邊個落去就行邊個<br />\n即係好似Arduino入面粒ATmega328咁<br />\n唔知你有無玩過<img src=\"/assets/faces/normal/sosad.gif\" class=\"hkgmoji\" /><br />\n<br />\n咁所以要做到「轉Program」依個功能<br />\n後面一定會有更加Low-level嘅Process去處理問題<br />\n咁就已經唔會喺啲Code入面見到個Process"},"citedBy":0,"replyTime":"2020-05-04T03:08:55.000Z","msg":"所謂low level嘅process包含左啲咩<img src=\"/assets/faces/normal/cry.gif\" class=\"hkgmoji\" />"},{"pid":"9bf51adca7f710de179cb08f69bb1ee6c90f73c0","tid":1998878,"uid":147721,"like":1,"dislike":0,"score":1,"citedBy":1,"replyTime":"2020-05-04T05:29:19.000Z","msg":"<a href=\"https://en.m.wikipedia.org/wiki/CPU_cache\" data-sr-url=\"https://r.lihkg.com/link?u=https%3A%2F%2Fen.m.wikipedia.org%2Fwiki%2FCPU_cache&d=eQX%2BqlmYp67lP1AM6ayufQXckNDuUEQQ0Md4EdtPbyE%3D&h=975b0473\" target=\"_blank\">https://en.m.wikipedia.org/wiki/CPU_cache</a>"},{"pid":"03c51f1d2153b3b9a9bd68a7357fd62074ec883c","tid":1998878,"uid":137768,"like":0,"dislike":0,"score":0,"quote":{"pid":"9bf51adca7f710de179cb08f69bb1ee6c90f73c0","tid":1998878,"uid":147721,"like":1,"dislike":0,"score":1,"citedBy":1,"replyTime":"2020-05-04T05:29:19.000Z","msg":"<a href=\"https://en.m.wikipedia.org/wiki/CPU_cache\" data-sr-url=\"https://r.lihkg.com/link?u=https%3A%2F%2Fen.m.wikipedia.org%2Fwiki%2FCPU_cache&d=eQX%2BqlmYp67lP1AM6ayufQXckNDuUEQQ0Md4EdtPbyE%3D&h=975b0473\" target=\"_blank\">https://en.m.wikipedia.org/wiki/CPU_cache</a>"},"citedBy":0,"replyTime":"2020-05-04T14:14:40.000Z","msg":"睇緊TLB嗰part 係咪啱方向?<img src=\"/assets/faces/normal/adore.gif\" class=\"hkgmoji\" />"}]}